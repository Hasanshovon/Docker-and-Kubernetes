Title: How Docker Containers Share Resources with the Host System

Introduction
This file outlines what resources Docker containers share with the host system, based on our implementation of two services using Docker Compose. 
The services, written in Python and Go, collect and display information about the environment they run in, such as IP addresses, running processes, disk usage, and uptime.

File System Sharing
Docker containers share certain parts of the host file system so that they can function properly and interact with each other. 
For example, the /etc/hosts file in each container is linked to the one on the host. This setup helps the containers resolve hostnames easily, making it possible for the services to communicate internally. 
Additionally, directories like /dev, /proc, and /sys are also mounted inside the containers, giving them access to system-level information and device files.
This enables the containers to act independently while still interacting with the host as needed.

Network Configuration
The containers are set up in a Docker bridge network called week7_default. Each container gets a unique IP address within this networkâ€”Service1 has 172.18.0.3 and Service2 has 172.18.0.2. 
This allows them to communicate directly without needing to expose Service2 externally. On the other hand, Service1 is mapped to host port 8199, making it accessible from outside the Docker environment.
This setup shows how Docker keeps the containers isolated while allowing controlled external access.

Process Isolation
Docker ensures strict separation between the processes running in containers and those on the host. 
For instance, when running ps -ax inside a container, only the processes running within that container are visible,
starting from process ID 1. This means the container has its own process namespace, which helps keep it isolated from the host system.
As a result, containers can't see or interfere with processes on the host.

Resource Sharing
Containers do share some of the host's hardware resources, such as CPU and memory, managed by Docker using control groups (cgroups).
In this setup, we didn't set specific limits on resource usage, so the containers can use as much of the host's CPU and memory as needed. 
Containers also use shared areas like /dev/shm for temporary storage, allowing for efficient communication between processes inside the container.

Conclusion
To sum up, Docker containers balance isolation and resource sharing in a way that allows them to run independently while using some parts of the host system when necessary.
This approach makes Docker an effective tool for securely deploying applications, enabling isolated services while efficiently managing resources shared with the host.
